# 文档历史存储机制说明

## 一、AppFlowy-Cloud 的实现方式

### 1.1 核心概念

AppFlowy-Cloud 使用 **快照（Snapshot）机制** 而不是变更日志（Change Log）来管理文档历史。

#### 两个关键概念：

1. **Snapshot（快照）**：

   - 这是 Yjs 的 `Snapshot` 对象（状态向量）
   - 表示文档在某个时间点的状态向量
   - 体积小，只包含状态信息，不包含完整内容
   - 用于快速比较和增量同步

2. **Doc State（文档状态）**：
   - 这是完整的文档状态（通过 `Y.encodeStateAsUpdate(doc)` 获取）
   - 包含文档的完整内容
   - 体积较大，但可以独立恢复文档
   - 用于完整恢复文档到某个版本

### 1.2 存储结构

AppFlowy-Cloud 使用两个表：

```sql
-- 快照元数据表（存储 Snapshot）
CREATE TABLE af_snapshot_meta (
    oid TEXT NOT NULL,
    workspace_id UUID NOT NULL,
    snapshot BYTEA NOT NULL,  -- Yjs Snapshot（状态向量）
    snapshot_version INTEGER NOT NULL,
    created_at BIGINT NOT NULL,
    ...
);

-- 快照状态表（存储 Doc State）
CREATE TABLE af_snapshot_state (
    snapshot_id UUID NOT NULL,
    workspace_id UUID NOT NULL,
    oid TEXT NOT NULL,
    doc_state BYTEA NOT NULL,  -- 完整文档状态
    doc_state_version INTEGER NOT NULL,
    created_at BIGINT NOT NULL,
    ...
);
```

### 1.3 工作原理

1. **创建快照**：

   - 定期（如每 10 次编辑或每 2 秒）创建快照
   - 生成 `Snapshot`（状态向量）和 `Doc State`（完整状态）
   - 两者都存储，但用途不同

2. **恢复文档**：

   - 使用 `Doc State` 可以直接恢复文档到某个版本
   - 使用 `Snapshot` 可以快速比较版本差异
   - 可以通过 `Snapshot + Doc State` 组合恢复

3. **存储优化**：
   - 快照存储在 S3（对象存储），元数据在 PostgreSQL
   - 使用 ZSTD 压缩减少存储空间
   - 限制快照数量（如最多保留 100 个）

### 1.4 关键代码

```rust
// AppFlowy-Cloud: snapshot_control.rs
pub async fn create_snapshot(&self, params: InsertSnapshotParams) -> AppResult<AFSnapshotMeta> {
    // 1. 获取当前文档的 Doc State
    let doc_state = collab.encode_as_update_v1();

    // 2. 创建 Snapshot（状态向量）
    let snapshot = collab.get_snapshot();

    // 3. 压缩并存储到 S3
    let compressed = zstd::encode_all(doc_state.as_ref(), ZSTD_COMPRESSION_LEVEL)?;
    self.s3.put_blob(&key, compressed.into(), None).await?;

    // 4. 存储元数据到 PostgreSQL
    // ...
}
```

## 二、当前实现的问题

### 2.1 问题分析

当前实现中，`snapshot_data` 和 `doc_state` 都存储的是相同的 `updates.content`（Yjs 的更新），这是**不正确的**。

**问题**：

- `updates.content` 是 Yjs 的增量更新（Update），不是 Snapshot
- 每次保存都存储完整的更新，没有利用 Yjs 的快照机制
- 无法正确恢复文档到历史版本

### 2.2 正确的实现方式

应该这样实现：

```typescript
// 1. 获取当前文档的完整状态（Doc State）
const docState = Y.encodeStateAsUpdate(ydoc);

// 2. 创建 Snapshot（状态向量）
const snapshot = Y.snapshot(ydoc);

// 3. 存储两者
await createSnapshot({
  snapshot_data: snapshot, // Yjs Snapshot（状态向量）
  doc_state: docState, // 完整文档状态
  // ...
});
```

## 三、改进建议

### 3.1 修改快照创建逻辑

应该在保存文档时：

1. **获取 Doc State**：使用 `Y.encodeStateAsUpdate(ydoc)` 获取完整状态
2. **创建 Snapshot**：使用 `Y.snapshot(ydoc)` 创建状态向量
3. **存储两者**：分别存储到 `snapshot_data` 和 `doc_state`

### 3.2 快照创建策略

参考 AppFlowy-Cloud：

1. **定期创建**：不是每次保存都创建，而是：

   - 每 N 次编辑后创建（如 10 次）
   - 或每 T 秒创建一次（如 2 秒）
   - 或手动触发

2. **限制数量**：最多保留 N 个快照（如 100 个），删除旧的

3. **压缩存储**：使用压缩算法（如 ZSTD）减少存储空间

### 3.3 恢复机制

恢复文档时：

1. **获取快照信息**：从数据库获取 `doc_state`
2. **恢复文档**：使用 `Y.applyUpdate(ydoc, doc_state)` 恢复
3. **验证完整性**：使用 `snapshot` 验证状态一致性

## 四、总结

### 4.1 关键区别

| 概念      | AppFlowy-Cloud           | 当前实现       | 说明        |
| --------- | ------------------------ | -------------- | ----------- |
| Snapshot  | Yjs Snapshot（状态向量） | Yjs Update     | ❌ 错误     |
| Doc State | 完整文档状态             | Yjs Update     | ❌ 错误     |
| 存储方式  | 定期创建快照             | 每次保存都创建 | ⚠️ 需要优化 |
| 恢复方式  | Doc State 恢复           | Update 恢复    | ❌ 可能失败 |

### 4.2 下一步行动

1. **修改快照创建逻辑**：正确使用 Yjs 的 Snapshot 和 Doc State
2. **实现快照调度**：定期创建，而不是每次保存
3. **优化存储**：压缩、限制数量
4. **实现恢复功能**：使用 Doc State 恢复文档
