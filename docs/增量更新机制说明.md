# 增量更新机制说明

## 增量数据来源

**Yjs 自动生成**：
- Yjs 的 `ydoc.on('update')` 事件会传递 `Uint8Array` 类型的增量更新
- 这是 Yjs 基于 CRDT（Conflict-free Replicated Data Type）算法自动生成的
- 每个 `update` 都是相对于前一个状态的增量

## 当前实现流程

### 前端流程

1. **监听更新**：
   ```typescript
   ydoc.on('update', (update: Uint8Array, origin) => {
     // 累积增量更新
     pendingUpdatesRef.current.push(update);
   });
   ```

2. **计算增量**：
   - **有状态向量时**：使用 `Y.encodeStateAsUpdate(ydoc, lastSavedStateVector)` 计算真正的增量
   - **无状态向量时**：使用累积的 update（fallback）

3. **保存**：
   - 自动保存：2秒防抖后保存增量
   - 手动保存：立即保存增量（如果有）

### 后端流程

1. **接收增量**：
   ```typescript
   if (updates.change_data && !updates.content) {
     // 应用增量到现有文档状态
     Y.applyUpdate(ydoc, updates.change_data);
     // 获取新的完整状态
     finalContent = Y.encodeStateAsUpdate(ydoc);
   }
   ```

2. **更新数据库**：
   - 存储完整状态（`finalContent`）
   - 记录增量数据（`change_data`）到变更日志

## 优化方案

### ✅ 已实现的优化

1. **使用状态向量计算真正的增量**：
   - 记录最后一次保存的状态向量（`Y.snapshot(ydoc)`）
   - 使用 `Y.encodeStateAsUpdate(ydoc, snapshot)` 计算增量
   - 这是真正的增量，不是全量

2. **自动保存和手动保存都使用增量**：
   - 自动保存：2秒防抖后保存增量
   - 手动保存：立即保存增量（如果有）

3. **文档加载时初始化状态向量**：
   - 文档加载后，立即记录状态向量
   - 确保后续保存可以计算真正的增量

### 🔄 当前问题

1. **`mergeYjsUpdates` 函数的问题**：
   - 当前实现：创建临时 doc，应用所有 update，然后 `Y.encodeStateAsUpdate(tempDoc)`
   - 问题：返回的是从空状态到最终状态的完整状态，不是真正的增量
   - 影响：当没有状态向量时，fallback 方案可能有问题

2. **状态向量丢失**：
   - 页面刷新后，状态向量会丢失
   - 需要从后端获取最后一次保存的状态向量

### 🚀 进一步优化建议

1. **后端返回状态向量**：
   - 保存成功后，返回当前的状态向量
   - 前端保存状态向量，用于下次计算增量

2. **优化 `mergeYjsUpdates`**：
   - 如果可能，直接传递所有 update 的数组
   - 或者，使用 Yjs 的 diff 功能计算真正的增量

3. **持久化状态向量**：
   - 将状态向量保存到 localStorage
   - 页面刷新后可以恢复

## 数据流图

```
用户编辑
  ↓
Yjs 触发 update 事件（增量）
  ↓
前端累积 update（防抖期间）
  ↓
计算增量（使用状态向量）
  ↓
发送到后端（change_data）
  ↓
后端应用增量到现有文档
  ↓
更新数据库（完整状态）
  ↓
记录变更日志（增量数据）
```

## 关键 API

### Yjs API

- `ydoc.on('update', callback)`: 监听增量更新
- `Y.snapshot(ydoc)`: 获取状态向量
- `Y.encodeStateAsUpdate(ydoc, snapshot?)`: 计算增量或全量
- `Y.applyUpdate(ydoc, update)`: 应用增量更新

### 后端 API

- `PUT /api/workspace/{workspace_id}/documents/{object_id}`:
  - `change_data`: Base64 编码的增量更新
  - `content`: Base64 编码的完整状态（可选）
  - `snapshot`: Base64 编码的状态向量（可选）

