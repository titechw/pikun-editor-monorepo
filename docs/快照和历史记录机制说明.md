# 快照和历史记录机制说明

## 当前实现的逻辑

### 1. 版本类型

- **大版本快照（Major Snapshot）**：

  - 定期创建（每 10 次编辑或每 5 分钟）
  - 存储在文件系统（压缩后）
  - 用于完整恢复文档到某个时间点
  - `version_type = 'major'`

- **小版本快照（Minor Snapshot）**：
  - 手动保存时创建
  - 也存储在文件系统
  - 用于标记重要的保存点
  - `version_type = 'minor'`

### 2. 变更日志（Change Log）

- **每次保存都记录**：

  - 自动保存：`change_type = 'auto_save'`
  - 手动保存：`change_type = 'manual_save'`
  - 存储变更数据（当前是完整状态，后续优化为增量）

- **变更日志表**：`document_changes`
  - `change_data`: 变更数据（Yjs Update）
  - `snapshot_id`: 关联的快照 ID（如果有）
  - `before_state_vector`: 变更前的状态向量
  - `after_state_vector`: 变更后的状态向量

### 3. 还原机制

**还原到某个版本**：

1. 找到最近的快照（大版本或小版本）
2. 从文件系统加载快照的 Doc State
3. 应用该快照之后的所有变更日志
4. 得到目标版本的文档状态

**示例**：

```
快照 A (大版本) -> 变更1 -> 变更2 -> 变更3 -> 快照 B (小版本) -> 变更4 -> 变更5 -> 快照 C (大版本)
```

要还原到"变更 5 之后"：

- 使用快照 C（大版本）直接恢复

要还原到"变更 3 之后"：

- 使用快照 B（小版本）恢复，然后应用变更 4 和变更 5

要还原到"变更 2 之后"：

- 使用快照 A（大版本）恢复，然后应用变更 3

## 当前实现的问题

### 问题 1：变更数据不是真正的增量

**当前**：`change_data` 存储的是完整的文档状态（`Y.encodeStateAsUpdate`）

**应该**：存储增量更新（Yjs 的 `update` 事件）

**解决方案**：

- 前端应该捕获 Yjs 的 `update` 事件，发送增量更新
- 或者，后端使用 Yjs 的 diff 算法计算增量

### 问题 2：缺少变更日志查询 API

**需要添加**：

- `GET /api/workspace/{workspace_id}/documents/{object_id}/changes` - 获取变更列表
- `GET /api/workspace/{workspace_id}/documents/{object_id}/changes/between/{from_snapshot_id}/{to_snapshot_id}` - 获取两个快照之间的变更

## 改进建议

### 1. 前端发送增量更新

修改前端，捕获 Yjs 的 `update` 事件：

```typescript
ydoc.on('update', (update: Uint8Array) => {
  // update 就是增量更新
  // 发送到后端保存
});
```

### 2. 优化变更日志存储

- 存储真正的增量更新（Yjs Update）
- 使用 Yjs 的 diff 算法计算变更
- 减少存储空间

### 3. 实现还原 API

- 根据快照 ID 还原文档
- 根据变更 ID 还原到某个变更点
- 支持预览某个版本的内容

## 总结

**当前机制**：

- ✅ 每次保存都记录变更日志
- ✅ 定期创建大版本快照
- ✅ 手动保存创建小版本快照
- ⚠️ 变更日志存储的是完整状态，不是增量（需要优化）
- ⚠️ 缺少变更日志查询 API（需要添加）

**还原流程**：

1. 找到最近的快照（大版本或小版本）
2. 加载快照的 Doc State
3. 应用快照之后的所有变更日志
4. 得到目标版本

这个机制基本符合你的需求，但需要优化变更日志的存储方式（从完整状态改为增量更新）。
