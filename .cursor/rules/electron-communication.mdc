---
description: Use this rule when implementing Electron main process and renderer process communication, IPC handlers, or renderer APIs
globs:
  [
    'electron/main/**/*.ts',
    'electron/preload/**/*.ts',
    'src/renderApis/**/*.ts',
  ]
alwaysApply: false
---

# Electron 渲染进程和主进程双向通信开发规则

## 触发条件

当用户提到以下关键词时，应该使用此规则：

- "Electron 通信"、"主进程"、"渲染进程"
- "IPC"、"ipcMain"、"ipcRenderer"
- "preload"、"contextBridge"
- "渲染进程和主进程通信"
- "Electron 双向通信"
- "调用渲染进程通信主进程"
- "渲染进程和主进程的相关通信"
- "前端点击...调用渲染进程通信主进程"
- "主进程执行操作"
- "渲染进程期望主进程执行操作"
- "IoC"、"依赖注入"、"服务管理"

## 使用场景

当需要实现渲染进程与主进程之间的双向通信，渲染进程期望主进程执行操作并返回结果时。

## IoC 服务架构规范

### 1. 服务注册中心

所有服务统一在 `electron/main/services/index.ts` 中注册：

```typescript
// electron/main/services/index.ts
import { Framework } from '../core';
import { DocumentSyncManager } from './documentSync';
import { GitManagerService } from './gitManager/GitManager';
import { ProjectManagerService } from './projectManager/ProjectManager';
import { SSHConfig } from './sshManager/SSHConfig';
import { ToolManager } from './tools/ToolManager';
import { WindowManager } from './winManager';

const framework = new Framework();
framework
	.service(SSHConfig)
	.service(ToolManager)
	.service(WindowManager)
	.service(GitManagerService, [SSHConfig, ToolManager])
	.service(ProjectManagerService, [ToolManager, SSHConfig])
	.service(DocumentSyncManager, [GitManagerService, ProjectManagerService]);

// 获取容器实例，这会触发所有服务的注册
framework.provider();

export { framework };
```

### 2. 服务类规范

#### 基础服务类（无 IPC 需求）

```typescript
// electron/main/services/[service]/[Service].ts
import { Service } from '../../core/components/service';

export class [Service] extends Service {
	constructor() {
		super();
		// 初始化逻辑
	}

	public methodName(): ReturnType {
		// 业务逻辑
		return result;
	}
}
```

#### IPC 服务类（需要与渲染进程通信）

```typescript
// electron/main/services/[service]/[Service].ts
import { BaseIpcService } from '../utils/BaseIpcService';
import { IpcHandle } from '../utils/handleDecortor';
import { EVENT_NAME } from '@shared/constant';

export class [Service] extends BaseIpcService {
	constructor() {
		super();
		// 初始化逻辑
	}

	@IpcHandle(EVENT_NAME.[MethodName])
	public [methodName](): [ReturnType] {
		// 实现业务逻辑
		return result;
	}
}
```

### 3. 服务使用规范

#### 在主进程中使用服务

```typescript
// electron/main/index.ts
import { framework } from './services';
import { WindowManager } from './services/winManager';

async function createWindow() {
	const winManager = framework.provider().get(WindowManager);
	// 使用服务
	const window = winManager.createWindow('main', options);
}
```

#### 服务间依赖注入

```typescript
// 服务构造函数中自动注入依赖
export class DocumentSyncManager extends BaseIpcService {
	private gitManager: GitManagerService;
	private projectManager: ProjectManagerService;

	// IoC 构造：容器会注入依赖
	constructor(
		gitManager: GitManagerService,
		projectManager: ProjectManagerService
	) {
		super();
		this.gitManager = gitManager;
		this.projectManager = projectManager;
	}
}
```

## 开发流程规范

### 1. 创建主进程服务目录

- 在 `electron/main/services` 下创建服务目录
- 创建服务类，根据需求选择继承 `Service` 或 `BaseIpcService`
- 使用 `@IpcHandle(EVENT_NAME.xxx)` 装饰器注册方法（仅 IPC 服务需要）
- 使用 `EVENT_NAME` 常量管理消息事件，在：`shared/constant.ts` 定义

### 2. 注册服务

在 `electron/main/services/index.ts` 中注册新服务：

```typescript
framework
	.service(NewService)
	.service(NewServiceWithDeps, [Dependency1, Dependency2]);
```

### 3. 使用服务

在需要的地方通过 IoC 容器获取服务：

```typescript
// 获取服务实例
const service = framework.provider().get(ServiceClass);

// 使用服务方法
const result = service.methodName();
```

### 4. 注册 preload 桥接接口（仅 IPC 服务需要）

在 `electron/preload/api.ts` 中：

```typescript
contextBridge.exposeInMainWorld(ELECTRON_BRIDGE_NAME, {
  [methodName]: () => ipcRenderer.invoke(EVENT_NAME.[MethodName]),
});
```

### 5. 定义类型声明

在 `electron/electron-env.d.ts` 中：

```typescript
declare global {
	interface Window {
		electron_app_api: {
			[methodName]: () => Promise<[ReturnType]>;
		};
	}
}
```

### 6. 定义渲染进程接口

在 `src/renderApis/interface.ts` 中：

```typescript
export abstract class BaseRenderApi {
	abstract [methodName](): Promise<RequestResult<[ReturnType]>>;
}
```

### 7. 实现渲染进程接口

在 `src/renderApis/index.ts` 中：

**PC 端实现（通过 preload 桥）：**

```typescript
class PCRenderApi extends BaseRenderApi {
  @wrapResponse()
  async [methodName]() {
    const res = await this.getPreloadApi().[methodName]();
    return res;
  }
}
```

**Web 端实现（通过 API 请求）：**

```typescript
class WebRenderApi extends BaseRenderApi {
	@wrapResponse()
	async [methodName]() {
		const res = await Promise.resolve({});
		return res;
	}
}
```

### 8. 在页面中使用

```typescript
useEffect(() => {
  const init = async () => {
    const res = await renderApi.[methodName]();
    console.log('result:', res);
  };
  init();
}, []);
```

## 关键注意事项

1. **IoC 容器管理**：所有服务必须在 `electron/main/services/index.ts` 中统一注册
2. **服务继承规范**：
   - 基础服务继承 `Service` 基类
   - IPC 服务继承 `BaseIpcService` 基类
   - 构造函数必须调用 `super()`
3. **依赖注入**：服务间依赖通过构造函数参数自动注入
4. **事件名称管理**：所有事件名称必须在 `shared/constant.ts` 中统一定义
5. **返回结构**：主进程方法返回结构应参考 `shared/infra/libs/axios.ts` 的 `Promise<RequestResult<V>>` 格式
6. **类型安全**：所有接口都要有明确的类型定义，避免使用 `any`
7. **错误处理**：使用 `@wrapResponse()` 装饰器统一处理响应
8. **平台适配**：PC 端通过 preload 桥调用，Web 端通过 API 请求

## 文件修改清单

### 新增基础服务时：

1. `electron/main/services/[service]/[Service].ts` - 创建服务类
2. `electron/main/services/index.ts` - 注册服务
3. 在需要的地方通过 `framework.provider().get(ServiceClass)` 使用

### 新增 IPC 服务时：

1. `shared/constant.ts` - 添加 EVENT_NAME 定义
2. `electron/main/services/[service]/[Service].ts` - 创建 IPC 服务类和方法
3. `electron/main/services/index.ts` - 注册服务
4. `electron/preload/api.ts` - 注册 preload 接口
5. `electron/electron-env.d.ts` - 添加类型声明
6. `src/renderApis/interface.ts` - 定义抽象接口
7. `src/renderApis/index.ts` - 实现具体接口
8. 页面组件中使用

## IoC 服务架构优势

1. **统一管理**：所有服务在 `services/index.ts` 中集中注册
2. **依赖注入**：自动处理服务间依赖关系
3. **生命周期管理**：框架自动管理服务生命周期
4. **类型安全**：完整的 TypeScript 类型支持
5. **可测试性**：便于单元测试和模拟
6. **解耦合**：服务间通过接口交互，降低耦合度

## 代码规范

- 所有组件使用文件夹/index.tsx 组织形式
- 单个文件最大 400 行，超过需要拆分
- 枚举变量必须使用枚举类型，不要直接定义类型
- 禁止使用 any，必须明确类型定义
- 所有方法都要有明确的参数和返回值类型

## 渲染进程请求 + 主进程推送进度 的通用链路（以 initializeRepository 为例）

本小节在不重复前文“开发流程规范”的基础上，描述一个完整的“渲染进程请求主进程执行任务，并在执行过程中主进程主动向渲染进程推送进度事件，最终返回结果”的通用设计和使用方式。可复用到任意需要长时任务进度反馈的场景（如 clone、pull、build、publish 等）。

### 角色与事件

- **请求-响应事件**：在 `shared/constant.ts` 的 `EVENT_NAME` 中定义，例如 `EVENT_NAME.InitializeRepository`。
- **窗口消息推送事件**：统一复用 `EVENT_NAME.WindowMessage`（单向主 → 渲染）与 `EVENT_NAME.WindowMessageRequest/Response`（需要应答的主 ↔ 渲染）。
- **窗口标识**：主进程通过 `EVENT_NAME.WindowId` 告知 `windowId`，预加载层缓存到 `sessionStorage`，供请求参数传递使用。

相关现有代码参考：

```192:206:/Users/kp/Documents/sass/help-center-projects/help-center-client/electron/main/services/gitManager/GitManager.ts
    @IpcHandle(EVENT_NAME.InitializeRepository)
    public async initializeRepository({ windowId }: { windowId?: string } = {}) {
        try {
            const emit = (status: string, message: string) => {
                if (windowId) {
                    this.windowManager.sendMessage(windowId, {
                        type: 'app-init',
                        data: { status, message },
                    });
                }
            };
```

```119:129:/Users/kp/Documents/sass/help-center-projects/help-center-client/electron/preload/api.ts
    // 文档同步助手相关
    initializeRepository: (params?: {}) =>
        ipcRenderer.invoke(
            EVENT_NAME.InitializeRepository,
            params ?? { windowId: currentWindowId }
        ),
```

```37:51:/Users/kp/Documents/sass/help-center-projects/help-center-client/src/components/AppInitialization/index.tsx
        // 通过窗口消息机制接收主进程进度（type = 'app-init'）
        const unsubscribe = renderApi.onWindowMessage((type, data) => {
            if (type !== 'app-init') return;
            if (!data) return;
            const { status: s, message } = data as {
                status: InitializationStatus['status'];
                message: string;
            };
            setStatus({ status: s, message });
            updateProgress(s);
            if (s === 'success') {
                setIsComplete(true);
                setTimeout(() => onComplete?.(), 800);
            }
        });
```

### 通用设计流程

1. 渲染进程触发请求（可选择携带 `windowId`）

```ts
// src/renderApis/index.ts（PC端）
await renderApi.initializeRepository({
	windowId: renderApi.getCurrentWindowId(),
});
```

2. 预加载桥转发请求，默认注入 `currentWindowId`

```ts
// electron/preload/api.ts
initializeRepository: (params?: { windowId?: string }) =>
	ipcRenderer.invoke(
		EVENT_NAME.InitializeRepository,
		params ?? { windowId: currentWindowId }
	);
```

3. 主进程处理长时任务，期间主动推送窗口消息

```ts
// electron/main/services/...Service.ts
@IpcHandle(EVENT_NAME.InitializeRepository)
async initializeRepository({ windowId }: { windowId?: string }) {
  const emit = (status: string, message: string) => {
    if (windowId) this.windowManager.sendMessage(windowId, { type: 'app-init', data: { status, message } });
  };
  emit('checking', '正在检查...');
  // ... 长时任务过程按阶段 emit('cloning' | 'pulling' | 'cleaning' | 'success' | 'error', msg)
  return { success: true, message: '完成' };
}
```

4. 渲染进程订阅推送消息并更新 UI

```ts
// 组件内使用（AppInitialization）
const unsubscribe = renderApi.onWindowMessage((type, data) => {
	if (type !== 'app-init') return;
	// 根据 data.status/data.message 更新 UI 与进度
});
useEffect(() => () => unsubscribe?.(), []);
```

5. 最终请求返回统一结构，完成/失败态一致处理

```ts
const result = await renderApi.initializeRepository();
if (!result.success) {
	// 失败态兜底提示；进度推送里也会发 error
}
```

### 关键约定与最佳实践

- **消息 type 约定**：长时任务的进度推送统一使用 `type = 'app-init'` 或按功能域划分的常量，前端只监听自己关心的 `type`。
- **状态语义**：推荐使用受控枚举的阶段值，如 `checking | cloning | pulling | cleaning | success | error`，保持 UI 与主进程的解耦与稳定。
- **windowId 传递**：尽量让预加载层自动注入当前窗口 `windowId`，避免页面层感知过多 IPC 细节；如需跨窗口指向性推送，显式传入指定 `windowId`。
- **统一包装响应**：渲染层通过 `@wrapResponse()` 处理一致的 `RequestResult` 结构；主进程 IPC 处理器也需保证返回结构一致，便于前端兜底与埋点。
- **取消监听**：组件卸载时务必调用 `unsubscribe`，避免内存泄漏和重复处理。
- **错误分层**：
  - 过程性错误：通过推送消息的 `status = 'error'` 与 `message` 显示给用户。
  - 终局性错误：IPC 返回 `success: false, message`，页面兜底展示。

### 适配其它任务的最小改动清单

- 在 `shared/constant.ts` 增加对应 IPC 事件名（如 `EVENT_NAME.PublishDocuments`）。
- 在主进程服务方法中沿用 `emit(windowId, { type, data })` 推送约定，仅替换 `type` 命名空间（如 `'docs-publish'`）与阶段状态枚举。
- 在预加载桥新增对应 `ipcRenderer.invoke(EVENT_NAME.XXX)` 的方法（若尚未暴露）。
- 在渲染层：
  - 调用 `renderApi.xxx()` 发起请求；
  - 使用 `renderApi.onWindowMessage` 订阅该功能域的 `type`，更新 UI；
  - 在组件卸载时取消订阅。
